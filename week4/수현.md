
# 분산 시스템을 위한 유일 ID 생성기 설계
보통의 유일 ID라고 한다면 관계형 데이터베이스의 auto_increment가 보편적이지만, 분산 환경의 데이터베이스의 경우엔 지연시간을 낮추기 어렵고 
한대의 경우에는 요구를 감당하기 어렵다는 단점이 있다.

## 문제 이해 및 설계 범위 확정

만약에 요구사항이 이렇게 들어온다고 가정해보자
* ID는 유일해야 한다
* ID는 숫자로만 구성되어야 한다
* ID는 64비트로 표현할 수 있는 값이여야 한다.
* ID는 발급 날짜에 따라 정렬 가능해야 한다.
* 초당 10,000개의 ID를 만들 수 있어야 한다.

## 개략적 설계안 제시 및 동의 구하기

### 다중 마스터 복제
![image](https://github.com/frost0807/system-design-interview/assets/98132695/c6c4626d-61bf-4907-9b62-d59f3673fc7d)
다음 ID값을 구할 때, 1만큼 증가시키는게 아니라 k(데이터베이스 서버의 수) 만큼 증가시킨다.
* 단점
  * 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다
  * ID의 유일성은 보장되지만 그 값이 시간흐름에 맞추어 커지도록 보장할 수는 없다.
  * 서버를 추가하거나 삭제할때 잘 동작하기 힘들다.


### UUID
UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리의 수이다.
* 장점
  * UUID를 만드는 것이 단순하며 서버와 조율할 필요가 없어 동기화 이슈도 없다.
  * 각 서버가 자기가 쓸 ID를 알아서 만들기 떄문에 규모 확장에 유리하다.

* 단점
  * ID가 128비트로 긴 편이다.
  * ID를 시간 순으로 정렬할 수 없다
  * ID에 숫자가 아닌 값이 들어갈 수도 있다.

### 티켓 서버
![image](https://github.com/frost0807/system-design-interview/assets/98132695/af268c80-2c4d-4a60-8154-f15528466c84)
auto_increment를 갖춘 데이터베이스를 서버를 티켓서버로 만들어 하나의 중앙 집중형으로 사용한다.

* 장점
  * 유일성이 보장되는 오직 숫자로만 구성된 ID를 만들 수 있다.
  * 구현하기 쉽고 중소 규모의 애플리케이션에게 적합하다.
* 단점
  * 타켓서버의 중요도가 너무 올라간다(SPOF). 장애가 발생 시 모든 서버가 영향을 받는다.

### 트위터 스노플레이크 접근법
트위터는 스노플레이크라고 부르는 독창적인 ID 생성 기법을 사용한 접근법이다.

이 접근법을 사용하면  ID를 바로 생성하는게 아니라 분할정복을 사용해 생성해야하는 ID의 구조를 여러 절로 분할한다.
![image](https://github.com/frost0807/system-design-interview/assets/98132695/a458b36d-7794-4362-8cbe-f15384a9e7e3)

* 사인 비트 : 1비트를 할당한다. 음수와 양수를 구분하는데 사용될 수 있다.
* 타임스탬프 : 41비트를 할당한다. epoch 이후로 몇 밀리초 경과 했는지의 시계열 값을 숫자로서 표현될 값이다.
* 데이터센터 ID : 5비트를 할당한다. 따라서 2^5 = 32개 데이터센터를 지원할 수 있다.
* 서버 ID :  5비트를 할당한다. 따라서 데이터 센터당 32개의 서버를 운용할 수 있다.
* 일련번호 : 12비트를 할당한다. 각 서버에서 ID를 생성할 때마다 이 값을 1씩 증가시킨다. 1 밀리초가 경과할 때마다 0으로 초기화된다.

타임스탬프는 41비트로 표현하는데 이는 대략 69년까지 표시할 수 있다. 따라서 69년동안만 작동하기 때문에 그 이후부턴 기원 시각을 바꾸거나 ID체계를 바꿔야한다.
일련번호는 12비트기 때문에, 2^12 = 4096개의 값을 가질 수 있다. 특정 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

### 마무리 
위에 조건을 다 만족하면서 독립성을 유지하는 ID생성법은 스노 플레이크 방식이다.
하지만 스노플레이크에는 추가적으로 살펴볼 주제가 있다.

* 시계 동기화 : 서버가 물리적으로 여러 곳에 있는 등 같은 시계가 아닐 수 있기 때문에 이를 동기화해주는 "네트워크 타임 프로토콜" 이 필요하다.
* 스노우 플레이크 각 섹션의 최적화 : 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호를 줄이고 타임스탬프의 절을 늘리는것이 효율적이다.



