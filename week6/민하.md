# 11장 뉴스 피드 시스템 설계
1. 피드 발행: 사용자가 게시글을 업로드 할 때, 캐시와 데이터베이스에 기록한다.
새 게시글은 친구의 피드에도 전송된다.
2. 뉴스 피드 생성: 모든 친구의 포스팅을 시간 역순으로 모아 가정한다.

### 뉴스 피드 API
클라이언트가 서버와 통신하기 위한 수단이다. HTTP 프로토콜 기반이며, 상태를 업데이트하거나 
뉴스 피드를 가져오기, 친구 추가 등의 작업을 수행한다.<br>
피드 발행과 피드 읽기 API 도 그 중 하나이다.
<br>

#### 피드 발행 API
스토리 포스팅하기 위한 API. HTTP POST 형태로 요청한다.<br>

    *POST/v1/me/feed*

인자:<br>
- body: 포스팅 내용<br>
- Authorization 헤더: API 호출 인증 위해 사용
<br>

#### 피드 읽기 API
뉴스 필드 GET 하는 API 다.<br>

    *GET/v1/me/feed*

인자:<br>
- Authorization 헤더: API 호출 인증 위해 사용
<br><br>

### 피드 발행
- 사용자: 모바일 앱, 브라우저에서 새 포스팅을 업로드함. POST/v1/me/feed API 사용
- 로드 밸런서: 트래픽을 웹 서버로 분산
- 웹 서버: HTTP 요청을 내부 서비스로 중계
- Post service: 새 포스팅을 데이터베이스와 캐시에 저장
- Fanout service: 새 포스팅을 친구의 뉴스 피드에 푸시하고 뉴스 피드 데이터는
캐시에 보관하여 빠르게 읽을 수 있도록 한다.
- Notification service: 친구에게 새 포스팅 알림, 푸시 알림 등을 한다.
<br><br>

### 뉴스 피드 생성
- 사용자: 뉴스 피드를 읽음. GET/v1/me/feed API 사용
- 로드 밸런서: 트래픽을 웹 서버로 분산
- 웹 서버: 트래픽을 뉴스 피드 서비스로 보냄
- 뉴스 피드 서비스: 캐시에서 뉴스 피드를 가져오는 서비스
- 뉴스 피드 캐시: 뉴스 피드를 렌더링할 때 필요한 피드 ID 보관

<br>

## 상세 설계
### 피드 발행 흐름 상세 설계
웹 서버와 Fanout service 를 다룬다.

<br><br>

#### 웹 서버
클라이언트와 통신, 인증, 처리율 제한등의 기능을 수행한다.<br>
인증 토큰을 Authorization 헤더에 넣고 API 호출 사용자만 포스팅 할 수 있어야 한다.
<br>한 사용자의 포스팅 수에 제한을 걸어 스팸과 유해 콘텐츠 방지를 한다.
<br><br>

#### Fanout 서비스
포스팅 전송 (Fanout) 서비스는 사용자의 새 포스팅을 모든 친구에게 전달한다.<br>
두 가지 모델이 있는데, 쓰기 시점 팬아웃(Fanout-on-write, push model), 읽기 시점 팬아웃
(Fanout-on-read, full model)이다.<br><br>

###### 쓰기 시점 팬아웃 (fanout-on-write, push model)
포스팅 기록 시점에 뉴스 피드 갱신. 포스팅 완료 시 해당 사용자 캐시에 포스팅 기록<br>

*장점*: 
- 실시간으로 갱신하고 친구에게 즉시 전송
- 새 포스팅 기록 순간 뉴스 피드에 갱신 (pre-computed)하기 때문에 뉴스 피드 읽는 시간이 짧아진다.
<br>

*단점*: 
- 친구가 많다면, 뉴스 피드 갱신시 시간이 많이 소요된다. hotkey 문제가 생긴다.
- 자주 이용하지 않은 사용자의 피드도 갱신해야 해서 낭비가 생긴다.
<br><br><br>

###### 읽기 시점 팬아웃 (fanout-on-read, pull model)
피드 읽을 시점에 갱신하므로 요청 기반(on-demand)모델이다. 타임 라인 로딩 시점에 갱신한다.
<br>

*장점*:
- 잘 사용하지 않는 사용자에게 유리하다. 로그인 전까지 자원 소모가 없다.
- 핫키 문제도 생기지 않는다.
<br>

*단점*: 
- 뉴스 피드 읽을 때 시간이 소요된다.

<br><Br>

대부분 사용자에게 푸시 모델을 사용하고, 팔로어가 많은 사용자는 필요시 포스팅을 받는 풀 모델을 사용하여 시스템
과부하를 방지한다. *안정 해시*로 분산하여 핫키 문제를 줄인다.<br>
팬아웃 서비스의 프로세스는 다음과 같다.<br>
1. 그래프 데이터베이스에서 친구 ID 목록을 가져온다.
2. 사용자 정보 캐시에서 친구 정보를 가져온다.
3. 친구 목록과 새 스토리의 포스팅 ID 메시지 큐에 넣는다.
4. 팬아웃 작업 서버가 메시지 큐에서 데이터 꺼내서 뉴스 피드 데이터를 캐시에 넣는다.

### 피드 읽기 흐름 상세 설계
1. 사용자가 뉴스 피드 읽기 요청을 보낸다.
2. 로드밸런서가 요청을 웹 서버 가운데 하나로 보낸다.
3. 웹 서버는 뉴스 피드를 호출한다.
4. 뉴스 피드 서비스는 캐시에서 포스팅 ID 목록을 가져온다.
5. 포스팅 캐시에서 정보를 가져와 뉴스 피드를 만든다.
6. JSON 형태로 클라이언트에 보낸다. 클라이언트는 피드를 렌더링 한다.

<br>

#### 캐시 구조
캐시는 뉴스 피드 시스템의 핵심 컴포넌트다.
책의 설계에서는 캐시를 뉴스 피드, 콘텐츠, 소셜 그래프, 행동, 횟수 다섯 계층으로 나눴다.
<br><br>

***

# 12장 채팅 시스템 설계
- latency 낮은 일대일 채팅
- 최대 100명 참여하는 그룹 채팅
- 사용자 접속 상태 표시
- 다양한 단말 지원, 하나 계정으로 동시 접속 지원
- 푸시 알림
- 5천만 DAU

## 개략적 설계안 제시 및 동의 구하기
- 클라이언트 메시지 수신
- 메시지 수신자(recipient) 결정 및 전달
- 수신자 오프라인일 때 메시지 보관

<br>
메시지 송신 클라이언트(sender)가 메시지를 채팅 서비스에 HTTP 프로토콜을 사용하여 보낸다.
<br>채팅 서비스 접속 시 keep-alive 헤더를 사용하여 클라-서버 연결을 끊지 않고 유지한다.
또 TCP 접속 과정의 handshake 를 줄일 수 있다.
그러나 서버에서 클라이언트로 보낼 때는 HTTP 통신에 한계가 있다.
따라서 방안으로 폴링, 롱 폴링, 웹 소켓을 알아볼 것이다.
<br><br>

### 폴링
폴링은 주기적으로 클라이언트가 서버에게 새 메시지를 물어본다. 메시지가 없을 경우 자원 낭비가 생긴다.
<br><br>

### 롱 폴링
폴링 방식을 보완한 방식이다. 새 메시지가 반환, 타임아웃 할 때 까지 연결 유지한다.
클라이언트가 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 한다.
- 메시지 송신 클라이언트와 수신 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.
<br>HTTP 서버는 보통 무상태이다. 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용할 경우,
메시지 받는 서버는 수신 클라이언트와 롱 폴링 연결을 갖지 않는 서버일 수 있다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 알 방법이 없다.
- 메시지를 많이 받지 않는 클라이언트도 타임아웃시 서버에 다시 접속하기에 비효율적

<br>

### 웹 소켓
서버가 클라이언트에 async 메시지를 보낼 때 널리 사용되는 기술<br>
클라이언트가 먼저 연결을 맺는다. 연결은 영구적, 양방향이다. 처음에는 HTTP 연결이고
특정 handshake 를 거쳐 웹 소켓 연결로 변한다. <br>
연결이 만들어 지면 서버는 클라이언트에게 비동기적 메시지 전송을 한다.<br>
방화벽 있는 환경도 가능하다. 80, 443과 같은 HTTP, HTTPS 프로토콜 포트번호를 사용한다.<br>
따라서 설계와 구현이 단순하고 직관적이지만, 영구적인 연결 특성으로 연결 관리를 효율적으로 해야한다.
<br><br>

### 개략적 설계안
채팅 시스템은 stateless, stateful, 3rd party 연동의 세부분으로 나누어 본다.
<br><br>

#### stateless 서비스
로드밸런서 뒤에 위치한다. 로드밸런서는 요청을 알맞은 경로에 전송하는 것이다.
<br>

#### stateful 서비스
유일하게 상태 유지가 필요한 채팅 서비스다. 각 클라이언트가 독립적으로 네트워크
연결을 해야하기 떄문이다. 보통, 클라이언트는 서버가 살아있는 한 서버 연결을 변경하지 않는다.
<br>

#### 3rd party 서비스 연동
푸시알림이 대표적이다.
<br>

#### 규모 확장성
서버 한 대 동시 접속 허용하는 정도를 생각한다. 그러나 SPOF 문제가 있기 때문에 수정해나가야 한다.
실시간 채팅을 위해 클라이언트는 채팅 서버와 웹 소켓의 연결을 유지해야하는 것을 유념한다.
<br>
- 채팅 서버는 클라이언트 사이의 메시지 중계 역할을 한다.
- 접속상태 서버는 사용자 접속 여부를 관리
- API 서버는 나머지 처리
- 알림 서버는 푸시 알림
- 키-값 저장소는 채팅 이력 보관

<br>

### 저장소
채팅 시스템은 두 데이터를 다룬다. 사용자 프로파일, 친구 등의 *일반 데이터*는 주로 관계형 
데이터 베이스에 보관한다. 나머지는 채팅 이력 데이터다.
<br><br>

채팅 이력 데이터는 최근 주고받은 메시지가 가장 빈번하게 사용된다.
<br>그러나, mention 메시지나, 특정 메시지로 점프 하는 등의 기능을 지원해야 한다.
<br>1:1 채팅앱의 경우 읽기:쓰기 비율이 1:1이라고 생각할 때,
**키-값 저장소**를 차용할 것이다.
<br>왜냐하면
- 수평적 규모확장이 쉽다.
- latency 가 낮다.
- 관계형 데이터베이스는 롱 테일로 무작위적 접근에 대한 비용이 늘어난다.
<br><br>

### 데이터 모델
#### 1:1 채팅 메시지 테이블
| message        |           |
|----------------|-----------|
| **message_id** | bigint    | 
| message_from   | bigint    |
| message_to     | bigint    |
| content        | text      |
| create_at      | timestamp |

기본 키는 message_id 로 메시지 순서를 쉽게 정하는 역할이다.
<br><br>

#### 그룹 채팅 메시지 테이블
| message        |           |
|----------------|-----------|
| **channel_id** | bigint    | 
| **message_id** | bigint    |
| message_to     | bigint    |
| content        | text      |
| create_at      | timestamp |

(channel_id, message_id) 복합키(composite key)를 기본 키로 사용한다.
채널은 채팅 그룹과 같은 뜻이고, 파티션 키로도 사용할 것이다.
<br><br>

#### 메시지 ID
- message_id 의 값은 고유해야 한다.
- ID 값은 정렬 가능하고 시간 순서와 일치한다.

<br>
RDBMS 는 auto_increment 가 대안이지만, NoSQL 은 제공하지 않는다.
*스노플레이크*를 이용하여 전역적 64-bit sequence number 를 생성할 수 있다.
혹은 지역적 순서 번호 생성기 (local sequence number generator) 를 이용하는 것이다.
ID 유일성은 같은 그룹 안에서 보증하는 것이 지역적인 것인데 메시지 사이의 순서는 채널 혹은
1:1 채팅 세션 안에서 유지하면 되기 때문이다.
<br><br>

## 상세 설계
### 서비스 탐색
클라이언트에 적합한 채팅 서비스를 추천한다. 위치나 서버 용량 등의 기준으로 설정하는데, 
오픈 소스 솔루션인 아파치 주키퍼 등을 이용한다.
<br>주키퍼의 동작 프로세스는 다음과 같다.
1. 사용자가 로그인 시도한다.
2. 로드밸런서가 로그인 요청을 API 서버 하나로 보낸다.
3. API 서버가 인증하면 최적의 채팅 서버를 찾는다.
4. 사용자는 채팅 서버와 웹 소켓 연결한다.

### 메시지 흐름
#### 1:1 채팅 메시지 프로세스
![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiGYZY%2FbtsIze1Y5w8%2FW4kBKp6u4LfX6CORARvJHk%2Fimg.png)
1. A 가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1 은 ID 생성기로 메시지 ID 결정
3. 채팅 서버 1 은 메시지 동기화 큐로 전송
4. 메시지 키-값 저장소에 보관
5. B 가 접속중일 시, 메시지는 채팅 서버 2로 전송<br>
B 가 오프라인 시, 푸시 알림 서버로 보냄
6. 채팅 서버 2 는  B에게 전송. 웹 소켓 연결이기 때문에 그걸 이용

<br>

#### 여러 단말 사이의 메시지 동기화
각 단말은 cur_max_message_id 라는 변수를 유지하는데, 최신 메시지 ID 를 추적하는 용도다.
- 수신자 ID 가 현재 로그인 한 ID 다.
- 키-값 저장소에 보관된 메시지로 ID 가 cur_max_message_id 보다 크다.
<br><br>를 만족 할 때, 새 메시지로 간주한다.
 <br><br>

#### 소규모 그룹 채팅의 메시지 프로세스
A, B, C 의 그룹 채팅이 있다고 가정했을 때, A 가 보낸 메시지는 B, C의 메시지 동기화 큐에 복사된다.
<br>
- 새 메시지가 왔을 경우 자기 큐만 보면 돼서 메시지 동기화 플로가 단순하다.
- 메시지를 수신자 별로 복사해서 큐에 넣는 작업이 크게 문제 되지 않는다. (그룹이 작기 떄문)


그러나 그룹 참여자가 많아질 수록 큐에 복사하는 것은 옳지 않다.
<br>

### 접속 상태 표시
#### 사용자 로그인
클라이언트와 실시간 서비스 사이에 웹 소켓이 연결되면 서버는 사용자와 last_active_at
 타임 스탬프 값을 키-값 보관소에 저장한다. 절차 후에 로그인 상태로 표시된다.
<br>

#### 로그아웃
키-값 저장소에 보관된 사용자 상태가 offline 으로 바뀐다.
<br>

#### 접속 장애
사용자 인터넷이 끊기면, 웹 소켓 연결도 끊긴다. 장애에 대응하는 방법은 사용자를 오프라인
으로 표시하고 연결이 복구될 시 온라인으로 변경하는 것이다.<br>
그러나 연결이 잠깐 끊어지는 것이 반복될 경우 상태를 일일이 변경하는 것은 옳지 않다.<br>
**heartbeat event** 를 이용하여 접속 상태를 확인할 수 있다.<br>
마지막 이벤트 받은 후 특정 시간 내에 이벤트를 받으면 온라인, 아니면 오프라인으로 변경하는 방식이다.
<br>

#### 상태 정보의 전송
상태정보 서버는 발행-구독 모델(publish-subscribe model)을 사용하여 친구 관계마다 채널을 하나씩 둔다.
이를 통해 친구는 사용자의 상태 변화를 인지한다. 클라이언트-서버 사이의 통신은 실시간 웹 소켓을 이용한다.
<br>
그룹 크기가 작으면 효과적이지만 커지면 비용과 시간이 소모된다. 해결할 수 있는 방법 중 하나는 
사용자가 그룹 채팅에 입장하는 순간만 상태를 읽거나 수동으로 변경하는 것이다.
<br><br>

## 마무리
- 미디어를 지원하는 방법
- 종단 간 암호화: 송신자, 수신자 외에 암호화한다.
- 캐시: 클라이언트에 읽은 메시지를 캐시하면 데이터를 줄일 수 있다.
- 로딩 속도 개선: 슬랙의 경우 사용자 데이터, 채널 등을 지역적 분산하여 속도 개선하였다.
- 오류 처리:
- - 채팅 서버 오류: 서버 하나에 수십만 사용자가 접속하는 상황을 생각하면, 서비스 탐색 기능이 동작하여 클라이언트에 새 서버를 배정할 수 있도록
한다.
- - 메시지 재선송: retry 나 queue 의 방법이 있다.

<br><br>
## 자료, 참조
- Alex Xu, (2021). 가상 면접 사례로 배우는 대규모 시스템 설계 기초, 인사이트






